# üêæ PawLang

**A modern systems programming language with Rust-level safety and cleaner syntax**

[![Version](https://img.shields.io/badge/version-0.1.4-blue.svg)](CHANGELOG.md)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![Build](https://img.shields.io/badge/build-passing-brightgreen.svg)](#)

---

## üöÄ Quick Start

### Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/PawLang.git
cd PawLang

# Build the compiler
zig build

# Compiler is located at zig-out/bin/pawc
```

### Hello World

```paw
fn main() -> i32 {
    println("Hello, PawLang! üêæ");
    return 0;
}
```

```bash
# Compile and run
./zig-out/bin/pawc hello.paw --run

# Or step by step
./zig-out/bin/pawc hello.paw    # Generate output.c
gcc output.c -o hello            # Compile
./hello                          # Run
```

---

## ‚ú® Core Features

### üöÄ Dual Backend Architecture (v0.1.4 NEW!) ‚≠ê

**Choose your backend: C for portability, LLVM for performance**

```bash
# C Backend (default) - Maximum compatibility
pawc hello.paw                    # Generates C code
pawc hello.paw --backend=c        # Explicit C backend

# LLVM Native Backend (NEW!) - Better optimization
pawc hello.paw --backend=llvm     # Generates LLVM IR
```

**Features:**
- ‚úÖ **C Backend**: Stable, portable, works everywhere
- ‚úÖ **LLVM Backend**: Native API integration, control flow support
- ‚úÖ **Control Flow**: if/else, while loops, break/continue
- ‚úÖ **Zero Memory Leaks**: Arena allocator, fully leak-free
- ‚úÖ **Local LLVM Toolchain**: No system dependencies

**LLVM Backend Highlights:**
```paw
// Full control flow support in LLVM backend
fn fibonacci(n: i32) -> i32 {
    if n <= 1 {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

fn sum_to_n(n: i32) -> i32 {
    let sum = 0;
    let i = 0;
    while i <= n {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}
```

**Backend Comparison:**

| Feature | C Backend | LLVM Backend |
|---------|-----------|--------------|
| Portability | ‚úÖ Excellent | ‚úÖ Good |
| Optimization | ‚úÖ Good | ‚úÖ Excellent |
| Control Flow | ‚úÖ Full | ‚úÖ Full |
| Compile Speed | ‚úÖ Fast | ‚ö° Very Fast |
| IR Quality | ‚úÖ C Code | ‚úÖ LLVM IR |

---

### üé® Automatic Type Inference (v0.1.3) ‚≠ê

**Cleaner code, same type safety:**

```paw
// Before (v0.1.2): Explicit type annotations required
let x: i32 = 42;
let sum: i32 = add(10, 20);
let vec: Vec<i32> = Vec<i32>::new();

// Now (v0.1.3): Automatic type inference!
let x = 42;                    // Inferred as i32
let sum = add(10, 20);         // Inferred as i32
let vec = Vec<i32>::new();     // Inferred as Vec<i32>
```

**Supported Inference:**
- ‚úÖ Literals (integers, strings, booleans)
- ‚úÖ Function call return values
- ‚úÖ Generic instantiation
- ‚úÖ Struct literals
- ‚úÖ Expression results

**Example:**
```paw
fn calculate(a: i32, b: i32) -> i32 {
    a + b
}

type Point = struct { x: i32, y: i32, }

fn main() -> i32 {
    let x = 42;                          // i32
    let message = "Hello";                // string
    let result = calculate(10, 20);      // i32
    let p = Point { x: 1, y: 2 };        // Point
    let vec = Vec<i32>::new();           // Vec<i32>
    
    // Explicit types still optional
    let explicit: i32 = 42;
    
    return result;
}
```

**Benefits:**
- üìù Less boilerplate
- üöÄ Faster development
- üîí Full type safety maintained
- üí° Clearer code intent

---

### üèóÔ∏è Engineering-Grade Module System (v0.1.3) ‚≠ê

**Multi-item import syntax:**

```paw
// math.paw - Module file
pub fn add(a: i32, b: i32) -> i32 { a + b }
pub fn multiply(a: i32, b: i32) -> i32 { a * b }
pub type Vec2 = struct { x: i32, y: i32, }

// main.paw - Using modules
// üÜï v0.1.3: Multi-item import (recommended)
import math.{add, multiply, Vec2};

// v0.1.2: Single-item import (still supported)
import math.add;
import math.multiply;
import math.Vec2;

fn main() -> i32 {
    let sum = add(10, 20);
    let product = multiply(5, 6);
    let v = Vec2 { x: 1, y: 2 };
    return sum + product;
}
```

**Module Entry Point (mod.paw):**
```
mylib/
‚îú‚îÄ‚îÄ mod.paw       # Module entry (re-exports)
‚îú‚îÄ‚îÄ core.paw      # Core functionality
‚îî‚îÄ‚îÄ utils.paw     # Utility functions

Usage:
import mylib.{hello, Data};  // Import from mod.paw
```

**Features:**
- ‚úÖ Multi-item imports reduce code
- ‚úÖ mod.paw module entry support
- ‚úÖ Modular standard library
- ‚úÖ Uses `.` syntax (not `::`)
- ‚úÖ Direct `import` (no `use` needed)
- ‚úÖ `pub` controls exports
- ‚úÖ Automatic module loading and caching

---

### üéØ Complete Generic System (v0.1.2)

**Generic Functions:**
```paw
fn identity<T>(x: T) -> T {
    return x;
}

let num = identity(42);      // T = i32
let text = identity("hello"); // T = string
```

**Generic Structs:**
```paw
type Box<T> = struct {
    value: T,
}

let box_int: Box<i32> = Box { value: 42 };
let box_str: Box<string> = Box { value: "paw" };
```

**Generic Methods** ‚≠ê:
```paw
type Vec<T> = struct {
    ptr: i32,
    len: i32,
    cap: i32,
    
    // Static method: Use :: to call
    fn new() -> Vec<T> {
        return Vec { ptr: 0, len: 0, cap: 0 };
    }
    
    fn with_capacity(cap: i32) -> Vec<T> {
        return Vec { ptr: 0, len: 0, cap: cap };
    }
    
    // Instance method: self doesn't need type!
    fn length(self) -> i32 {
        return self.len;
    }
}

// Usage
let vec: Vec<i32> = Vec<i32>::new();        // Static method
let len: i32 = vec.length();                // Instance method
```

---

### üîí Type Safety

- **18 Precise Types**: `i8`-`i128`, `u8`-`u128`, `f32`, `f64`, `bool`, `char`, `string`, `void`
- **Compile-time type checking**
- **Zero runtime overhead** (full monomorphization)

### üé® Clean Syntax

**Only 19 Core Keywords:**
```
fn let type import pub if else loop break return
is as async await self Self mut true false in
```

### üîÑ Unified Design

- **Unified Declarations**: `let` for variables, `type` for types
- **Unified Loops**: `loop` for all loop forms
- **Unified Patterns**: `is` for all pattern matching

### üì¶ Powerful Type System

**Structs:**
```paw
type Point = struct {
    x: i32,
    y: i32,
    
    fn new(x: i32, y: i32) -> Point {
        return Point { x: x, y: y };
    }
    
    fn distance(self) -> f64 {
        return sqrt(self.x * self.x + self.y * self.y);
    }
}
```

**Enums (Rust-style):**
```paw
type Result = enum {
    Ok(i32),
    Err(i32),
}

type Option = enum {
    Some(i32),
    None(),
}
```

**Pattern Matching:**
```paw
let result = value is {
    Some(x) => x * 2,
    None() => 0,
    _ => -1,
};
```

### üí¨ String Interpolation

```paw
let name = "Alice";
let age: i32 = 25;

println("Hello, $name!");              // Simple interpolation
println("You are ${age} years old.");  // Expression interpolation
```

### ‚ùì Error Handling

```paw
fn divide(a: i32, b: i32) -> Result {
    return if b == 0 { Err(1) } else { Ok(a / b) };
}

fn process() -> Result {
    let value = divide(10, 2)?;  // ? operator propagates errors
    return Ok(value * 2);
}
```

### üî¢ Array Support

```paw
// Array literals
let arr = [1, 2, 3, 4, 5];

// Array indexing
let first = arr[0];

// Array types
let numbers: [i32] = [10, 20, 30];        // Dynamic size
let fixed: [i32; 5] = [1, 2, 3, 4, 5];   // Fixed size

// Array iteration
loop item in arr {
    println("$item");
}
```

---

## üìö Standard Library

### Built-in Functions

```paw
println(msg: string)  // Print with newline
print(msg: string)    // Print without newline
eprintln(msg: string) // Error output
eprint(msg: string)   // Error output without newline
```

### Generic Containers (v0.1.2)

**Vec<T>** - Dynamic Array:
```paw
let vec: Vec<i32> = Vec<i32>::new();
let vec2: Vec<i32> = Vec<i32>::with_capacity(10);
let len: i32 = vec.length();
let cap: i32 = vec.capacity_method();
```

**Box<T>** - Smart Pointer:
```paw
let box: Box<i32> = Box<i32>::new(42);
```

### Error Handling Types

```paw
type Result = enum { Ok(i32), Err(i32) }
type Option = enum { Some(i32), None() }
```

---

## üõ†Ô∏è Command Line Tools

```bash
# Compile to C code (default)
pawc hello.paw

# Compile to LLVM IR (NEW in v0.1.4!)
pawc hello.paw --backend=llvm

# Compile to executable
pawc hello.paw --compile

# Compile and run
pawc hello.paw --run

# Show version
pawc --version

# Show help
pawc --help
```

### Options

- `-o <file>` - Specify output file name
- `--compile` - Compile to executable (C backend only)
- `--run` - Compile and run (C backend only)
- `--backend=c` - Use C backend (default)
- `--backend=llvm` - Use LLVM native backend (v0.1.4)
- `-v` - Verbose output
- `--help` - Show help

### LLVM Backend Workflow

```bash
# Generate LLVM IR
pawc program.paw --backend=llvm

# Compile IR to executable (if local LLVM installed)
llvm/install/bin/clang output.ll -o program

# Run
./program
```

---

## üìñ Example Programs

Check the `examples/` directory:

- `hello.paw` - Hello World
- `array_complete.paw` - Array operations
- `string_interpolation.paw` - String interpolation
- `error_propagation.paw` - Error handling
- `enum_error_handling.paw` - Enum error handling
- `vec_demo.paw` - Vec container demo
- **`generic_methods.paw`** - Generic methods demo (v0.1.2)
- `generics_demo.paw` - Generic functions demo
- **`llvm_demo.paw`** - LLVM backend demo (v0.1.4)

Check the `tests/` directory:

- `test_static_methods.paw` - Static methods test
- `test_instance_methods.paw` - Instance methods test
- `test_methods_complete.paw` - Complete methods test
- `test_generic_struct_complete.paw` - Generic structs test

---

## üéØ Version History

### v0.1.4 (2025-01-09) - Current Version üöÄ

**Complete LLVM Integration**

- ‚úÖ LLVM 19.1.6 native backend
- ‚úÖ Dual backend architecture (C + LLVM)
- ‚úÖ Control flow support (if/else, while, break, continue)
- ‚úÖ Zero memory leaks (Arena allocator)
- ‚úÖ Local LLVM toolchain (no system dependencies)
- ‚úÖ Custom C API bindings
- ‚úÖ Simplified backend selection

[Read More ‚Üí](RELEASE_NOTES_v0.1.4.md)

### v0.1.3 (2025-10-09)

**Type Inference & Enhanced Modules**

- ‚úÖ Automatic type inference
- ‚úÖ Multi-item imports
- ‚úÖ Enhanced module system
- ‚úÖ Argument validation

[Read More ‚Üí](docs/RELEASE_NOTES_v0.1.3.md)

### v0.1.2 (2025-10-08)

**Complete Generic Methods**

- ‚úÖ Generic static methods
- ‚úÖ Generic instance methods
- ‚úÖ **self parameter without type** - PawLang's unique design!
- ‚úÖ Automatic monomorphization

### v0.1.1 (2025-10-09)

**Complete Generic System**

- ‚úÖ Generic functions
- ‚úÖ Generic structs
- ‚úÖ Type inference
- ‚úÖ Monomorphization

### v0.1.0

**Base Language Features**

- ‚úÖ Complete syntax and type system
- ‚úÖ Compiler toolchain
- ‚úÖ Standard library basics

---

## üèóÔ∏è Compiler Architecture

```
PawLang Source (.paw)
    ‚Üì
Lexer
    ‚Üì
Parser
    ‚Üì
Type Checker
    ‚Üì
Generic Monomorphizer ‚Üê v0.1.2
    ‚Üì
Code Generator
    ‚îú‚Üí C Backend (default)
    ‚îî‚Üí LLVM Native Backend ‚Üê v0.1.4 NEW!
    ‚Üì
Executable
```

### Project Structure

```
PawLang/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.zig                  # Compiler entry point
‚îÇ   ‚îú‚îÄ‚îÄ lexer.zig                 # Lexical analysis
‚îÇ   ‚îú‚îÄ‚îÄ parser.zig                # Syntax analysis
‚îÇ   ‚îú‚îÄ‚îÄ ast.zig                   # AST definitions
‚îÇ   ‚îú‚îÄ‚îÄ typechecker.zig           # Type checking
‚îÇ   ‚îú‚îÄ‚îÄ generics.zig              # Generic system (v0.1.1+)
‚îÇ   ‚îú‚îÄ‚îÄ codegen.zig               # C code generation
‚îÇ   ‚îú‚îÄ‚îÄ llvm_c_api.zig            # LLVM C API bindings (v0.1.4)
‚îÇ   ‚îú‚îÄ‚îÄ llvm_native_backend.zig   # LLVM native backend (v0.1.4)
‚îÇ   ‚îú‚îÄ‚îÄ c_backend.zig             # C backend (v0.1.4)
‚îÇ   ‚îú‚îÄ‚îÄ token.zig                 # Token definitions
‚îÇ   ‚îú‚îÄ‚îÄ module.zig                # Module system
‚îÇ   ‚îî‚îÄ‚îÄ std/
‚îÇ       ‚îî‚îÄ‚îÄ prelude.paw           # Standard library
‚îú‚îÄ‚îÄ llvm/                         # Local LLVM installation (v0.1.4)
‚îÇ   ‚îú‚îÄ‚îÄ 19.1.6/                   # LLVM source
‚îÇ   ‚îú‚îÄ‚îÄ build/                    # Build artifacts
‚îÇ   ‚îî‚îÄ‚îÄ install/                  # Installed LLVM
‚îú‚îÄ‚îÄ scripts/                      # Build scripts (v0.1.4)
‚îÇ   ‚îú‚îÄ‚îÄ setup_llvm_source.sh      # LLVM setup
‚îÇ   ‚îú‚îÄ‚îÄ build_llvm_local.sh       # LLVM build
‚îÇ   ‚îî‚îÄ‚îÄ compile_with_local_llvm.sh # LLVM compile helper
‚îú‚îÄ‚îÄ examples/                     # Example programs
‚îú‚îÄ‚îÄ tests/                        # Test suite
‚îú‚îÄ‚îÄ docs/                         # Documentation
‚îÇ   ‚îú‚îÄ‚îÄ QUICKSTART.md             # Quick start guide
‚îÇ   ‚îú‚îÄ‚îÄ LLVM_BUILD_GUIDE.md       # LLVM setup guide (v0.1.4)
‚îÇ   ‚îî‚îÄ‚îÄ ROADMAP_v0.1.4.md         # Current roadmap
‚îú‚îÄ‚îÄ build.zig                     # Build configuration
‚îú‚îÄ‚îÄ CHANGELOG.md                  # Change log
‚îî‚îÄ‚îÄ README.md                     # This file
```

---

## üé® Design Philosophy

### 1. Simplicity First

PawLang pursues minimal syntax:
- Only 19 keywords
- Unified declaration syntax
- Intuitive design

### 2. Type Safety

- Compile-time type checking
- Generic system ensures type safety
- Zero runtime type errors

### 3. Zero-Cost Abstractions

- All generics expanded at compile time
- No virtual function tables
- Performance equivalent to hand-written C

### 4. Modern Features

- Generics (functions, structs, methods)
- Pattern matching
- String interpolation
- Error propagation (`?` operator)
- Method syntax
- **Dual backends** (C + LLVM)

---

## üí° Language Highlights

### self Parameter Without Type ‚≠ê

This is PawLang's unique design:

```paw
type Vec<T> = struct {
    len: i32,
    
    // ‚úÖ PawLang - Clean and elegant
    fn length(self) -> i32 {
        return self.len;
    }
}

// vs Rust
// fn length(&self) -> i32 { ... }
```

### Unified Method Calls

```paw
// Static method - :: syntax
let vec: Vec<i32> = Vec<i32>::new();

// Instance method - . syntax
let len: i32 = vec.length();
```

### Complete Generic Support

```paw
// Generic function
fn swap<T>(a: T, b: T) -> i32 { ... }

// Generic struct
type Box<T> = struct { value: T }

// Generic method
fn get(self) -> T { return self.value; }
```

### Dual Backend Architecture (v0.1.4)

```bash
# C Backend - Maximum portability
pawc app.paw --backend=c

# LLVM Backend - Maximum performance
pawc app.paw --backend=llvm
```

---

## üìä Performance

- **Compile Speed**: <10ms (typical programs)
- **Runtime Performance**: Equivalent to C (zero-overhead abstractions)
- **Memory Usage**: No GC, fully manual control
- **LLVM Optimization**: Better optimization with LLVM backend

---

## üß™ Testing

```bash
# Run all tests
./zig-out/bin/pawc tests/test_methods_complete.paw --run

# Static methods test
./zig-out/bin/pawc tests/test_static_methods.paw --run

# Instance methods test
./zig-out/bin/pawc tests/test_instance_methods.paw --run

# LLVM backend test (v0.1.4)
zig build run-llvm
```

---

## üåü Why Choose PawLang?

| Feature | PawLang | Rust | C | Python |
|---------|---------|------|---|--------|
| Generics | ‚úÖ Complete | ‚úÖ | ‚ùå | ‚ùå |
| Type Safety | ‚úÖ | ‚úÖ | ‚ö†Ô∏è | ‚ùå |
| Zero Overhead | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |
| Clean Syntax | ‚úÖ | ‚ö†Ô∏è | ‚ö†Ô∏è | ‚úÖ |
| self Without Type | ‚úÖ | ‚ùå | N/A | ‚úÖ |
| LLVM Backend | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå |
| Learning Curve | Low | High | Medium | Low |

**PawLang = Rust's Safety + C's Performance + Python's Simplicity + LLVM's Optimization**

---

## üîß Development

### Dependencies

- **Zig** 0.14.0 or higher
- **GCC** or **Clang** (optional, for C backend)
- **CMake** and **Ninja** (optional, for building local LLVM)

### Building

```bash
# Development build
zig build

# Release build
zig build -Doptimize=ReleaseFast

# Build with LLVM backend (auto-detected)
zig build

# Quick test with LLVM
zig build run-llvm
```

### Building Local LLVM (Optional)

```bash
# Setup LLVM source
./scripts/setup_llvm_source.sh

# Build LLVM locally (~30-60 minutes)
./scripts/build_llvm_local.sh

# Now LLVM backend is available!
./zig-out/bin/pawc app.paw --backend=llvm
```

For detailed LLVM setup, see [LLVM Build Guide](docs/LLVM_BUILD_GUIDE.md).

### Contributing

Contributions welcome! Please ensure:
- Code follows existing style
- All tests pass
- Documentation is updated

---

## üìÑ Documentation

- [CHANGELOG.md](CHANGELOG.md) - Complete change history
- [RELEASE_NOTES_v0.1.4.md](RELEASE_NOTES_v0.1.4.md) - v0.1.4 release notes
- [LLVM_BUILD_GUIDE.md](docs/LLVM_BUILD_GUIDE.md) - LLVM setup guide
- [QUICKSTART.md](docs/QUICKSTART.md) - Quick start guide
- [examples/](examples/) - Example code
- [tests/](tests/) - Test cases

---

## üó∫Ô∏è Roadmap

### v0.1.5 (Planned)

- [ ] for loops in LLVM backend
- [ ] More LLVM optimizations
- [ ] Enhanced error messages
- [ ] String type improvements

### Future Versions

- [ ] Trait system
- [ ] Operator overloading
- [ ] Async/await
- [ ] Package manager
- [ ] LSP support

---

## üìä Project Status

| Component | Status | Completion |
|-----------|--------|------------|
| Lexer | ‚úÖ | 100% |
| Parser | ‚úÖ | 100% |
| Type Checker | ‚úÖ | 100% |
| Generic System | ‚úÖ | 100% |
| C Backend | ‚úÖ | 100% |
| LLVM Backend | ‚úÖ | 80% |
| Standard Library | üöß | 30% |
| Documentation | ‚úÖ | 90% |

---

## üèÜ Milestones

- **v0.1.0** - Base language ‚úÖ
- **v0.1.1** - Complete generic system ‚úÖ
- **v0.1.2** - Generic methods ‚úÖ
- **v0.1.3** - Type inference & modules ‚úÖ
- **v0.1.4** - LLVM integration ‚úÖ ‚≠ê **Current**
- **v0.2.0** - Trait system (planned)
- **v1.0.0** - Production ready (goal)

---

## ü§ù Contributors

Thanks to all developers who contributed to PawLang!

---

## üìÑ License

MIT License

---

## üîó Links

- **GitHub**: [PawLang Repository](#)
- **Quick Start**: [5-Minute Guide](docs/QUICKSTART.md)
- **Full Documentation**: [View All Docs](docs/)
- **Example Code**: [View Examples](examples/)
- **Module System**: [Module System Docs](docs/MODULE_SYSTEM.md)
- **LLVM Guide**: [LLVM Build Guide](docs/LLVM_BUILD_GUIDE.md)
- **Changelog**: [CHANGELOG.md](CHANGELOG.md)

---

**Built with ‚ù§Ô∏è using Zig and LLVM**

**üêæ Happy Coding with PawLang!**
