// ?错误处理完整集成测试
// 展示错误处理的所有功能

fn divide(a: i32, b: i32) -> i32? {
    if b == 0 {
        return err("Division by zero");
    }
    return ok(a / b);
}

fn safe_calculate(a: i32, b: i32, c: i32) -> i32? {
    let x = divide(a, b)?;
    let y = divide(x, c)?;
    return ok(y * 2);
}

fn main() -> i32 {
    println("╔═══════════════════════════════════════════════════╗");
    println("║  ?错误处理完整功能测试                           ║");
    println("╚═══════════════════════════════════════════════════╝");
    
    // 测试1：基础ok/err创建
    println("\n【测试1：创建Optional值】");
    let success_result = divide(10, 2);
    println("  ✓ ok(value) created");
    
    let error_result = divide(10, 0);
    println("  ✓ err(message) created");
    
    // 测试2：?错误传播
    println("\n【测试2：错误自动传播】");
    let chain_success = safe_calculate(20, 2, 5);
    println("  ✓ 成功情况：所有?都通过");
    
    let chain_error1 = safe_calculate(20, 0, 5);
    println("  ✓ 错误传播：第一个?捕获错误");
    
    let chain_error2 = safe_calculate(20, 2, 0);
    println("  ✓ 错误传播：第二个?捕获错误");
    
    // 测试3：多层嵌套传播
    println("\n【测试3：多层错误传播】");
    let multi_result = safe_calculate(100, 5, 2);
    println("  ✓ 多层嵌套：全部成功");
    
    let multi_error = safe_calculate(100, 0, 2);
    println("  ✓ 多层嵌套：错误正确传播");
    
    println("\n╔═══════════════════════════════════════════════════╗");
    println("║  ✅ ?错误处理完整功能测试通过！                  ║");
    println("║                                                   ║");
    println("║  PawLang的?错误处理：                             ║");
    println("║  ✓ T? 类型系统                                    ║");
    println("║  ✓ ok/err 构造                                    ║");
    println("║  ✓ ? 错误自动传播                                 ║");
    println("║  ✓ 零运行时开销                                   ║");
    println("║  ✓ 完全类型安全                                   ║");
    println("╚═══════════════════════════════════════════════════╝");
    
    return 0;
}

