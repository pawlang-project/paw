// Paw v3 å®Œæ•´ç¤ºä¾‹ - Web API + æ•°æ®åº?

import http.{Server, Request, Response, Method}
import db.Database
import json.Json

// ç”¨æˆ·ç±»å‹
type User = struct {
    id: int
    name: string
    email: string
    age: int
    
    fn validate(self) -> Result<(), string> {
        if self.name.is_empty() { 
            Err("Name cannot be empty") 
        }
        else if !self.email.contains("@") { 
            Err("Invalid email") 
        }
        else if self.age < 0 or self.age > 150 { 
            Err("Invalid age") 
        }
        else { 
            Ok(()) 
        }
    }
    
    fn display(self) -> string {
        "$self.name ($self.email) - $self.age years old"
    }
}

// API å“åº”ç±»å‹
type ApiResponse<T> = enum {
    Success(T)
    Error { code: int, message: string }
    NotFound
    
    fn json(self) -> string {
        self is {
            Success(data) -> Json.encode(data)
            Error { code, message } -> """{"error": {"code": $code, "message": "$message"}}"""
            NotFound -> """{"error": "Not found"}"""
        }
    }
}

// æ•°æ®åº“è¿æ¥æ± 
type DbPool = struct {
    pool: Database
    
    fn new(url: string) async -> Result<Self, string> {
        let pool = Database.connect(url).await?
        Ok(DbPool { pool })
    }
    
    fn query<T>(self, sql: string, params: [Value]) async -> Result<T, string> {
        self.pool.execute(sql, params).await
    }
}

// ç”¨æˆ·æœåŠ¡
type UserService = struct {
    db: DbPool
    
    fn get_all(self) async -> Result<[User], string> {
        self.db.query(
            "SELECT * FROM users ORDER BY name",
            []
        ).await
    }
    
    fn get_by_id(self, id: int) async -> Result<Option<User>, string> {
        let users: [User] = self.db.query(
            "SELECT * FROM users WHERE id = ?",
            [id as Value]
        ).await?
        
        Ok(users.first())
    }
    
    fn create(self, user: User) async -> Result<int, string> {
        user.validate()?
        
        let result = self.db.query(
            "INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
            [user.name as Value, user.email as Value, user.age as Value]
        ).await?
        
        Ok(result.last_insert_id())
    }
    
    fn update(self, id: int, user: User) async -> Result<(), string> {
        user.validate()?
        
        self.db.query(
            "UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?",
            [user.name as Value, user.email as Value, user.age as Value, id as Value]
        ).await?
        
        Ok(())
    }
    
    fn delete(self, id: int) async -> Result<(), string> {
        self.db.query(
            "DELETE FROM users WHERE id = ?",
            [id as Value]
        ).await?
        
        Ok(())
    }
}

// HTTP å¤„ç†å™?
type Handler = struct {
    service: UserService
    
    fn handle(self, req: Request) async -> Response {
        let result = self.handle_internal(req).await
        
        result is {
            Ok(response) -> response
            Err(error) -> {
                println("Error: $error")
                Response.error(500, error)
            }
        }
    }
    
    fn handle_internal(self, req: Request) async -> Result<Response, string> {
        (req.method(), req.path()) is {
            (Method.GET, "/api/users") -> {
                let users = self.service.get_all().await?
                Ok(Response.json(ApiResponse.Success(users)))
            }
            
            (Method.GET, path) if path.starts_with("/api/users/") -> {
                let id = path.strip_prefix("/api/users/")
                    else { return Err("Invalid path") }
                
                let id = id.parse::<int>()
                    else { return Err("Invalid user ID") }
                
                let user = self.service.get_by_id(id).await?
                
                user is {
                    Some(u) -> Ok(Response.json(ApiResponse.Success(u)))
                    None -> Ok(Response.json(ApiResponse.NotFound))
                }
            }
            
            (Method.POST, "/api/users") -> {
                let user: User = req.json().await?
                let id = self.service.create(user).await?
                Ok(Response.created(id))
            }
            
            (Method.PUT, path) if path.starts_with("/api/users/") -> {
                let id = path.strip_prefix("/api/users/")?.parse::<int>()?
                let user: User = req.json().await?
                self.service.update(id, user).await?
                Ok(Response.ok())
            }
            
            (Method.DELETE, path) if path.starts_with("/api/users/") -> {
                let id = path.strip_prefix("/api/users/")?.parse::<int>()?
                self.service.delete(id).await?
                Ok(Response.no_content())
            }
            
            _ -> Ok(Response.not_found())
        }
    }
}

// ä¸­é—´ä»¶ï¼šæ—¥å¿—
fn log_middleware(req: Request, next: fn(Request) async -> Response) async -> Response {
    let start = Instant.now()
    let method = req.method()
    let path = req.path()
    
    println("-> $method $path")
    
    let response = next(req).await
    
    let duration = start.elapsed().as_millis()
    let status = response.status()
    
    println("<- $status (${duration}ms)")
    
    response
}

// ä¸»å‡½æ•?
fn main() async -> Result<(), string> {
    println("ğŸš€ Starting Paw API Server...")
    
    // è¿æ¥æ•°æ®åº?
    let db = DbPool.new("postgresql://localhost/myapp").await?
    println("âœ?Database connected")
    
    // åˆ›å»ºæœåŠ¡
    let service = UserService { db }
    let handler = Handler { service }
    
    // é…ç½®æœåŠ¡å™?
    let server = Server.builder()
        .bind("0.0.0.0:8080")?
        .middleware(log_middleware)
        .build()
    
    println("âœ?Server configured")
    println("")
    println("ğŸ“ Available endpoints:")
    println("  GET    /api/users")
    println("  GET    /api/users/:id")
    println("  POST   /api/users")
    println("  PUT    /api/users/:id")
    println("  DELETE /api/users/:id")
    println("")
    println("ğŸŒ Listening on http://localhost:8080")
    println("Press Ctrl+C to stop")
    
    // å¯åŠ¨æœåŠ¡å™?
    server.serve(|req| handler.handle(req)).await
}

// æµ‹è¯•
#[test]
fn test_user_validation() {
    let valid = User {
        id: 1
        name: "Alice"
        email: "alice@example.com"
        age: 30
    }
    assert(valid.validate().is_ok())
    
    let invalid = User {
        id: 2
        name: ""
        email: "invalid"
        age: -5
    }
    assert(invalid.validate().is_err())
}

#[test]
fn test_api_response() async {
    let response = ApiResponse.Success(42)
    let json = response.json()
    assert(json.contains("42"))
}

