// JSON 解析器
// v0.2.0 - 纯 PawLang 实现
// 
// 功能:
// - JSON 字符串解析
// - JSON 对象创建
// - JSON 数组操作
// - JSON 序列化
//
// 示例:
// ```
// import json.{parse, stringify, JsonValue};
// 
// let json_str = '{"name": "Alice", "age": 30}';
// let parsed = parse(json_str);
// 
// let output = stringify(parsed);
// ```

// ============================================================================
// JSON 值类型（简化版 - 暂不支持嵌套）
// ============================================================================

// 简化的 JSON 值类型（v0.2.0 第一版）
// 注意：当前不支持嵌套的数组和对象，等待 Vec<T> 完善
pub type JsonValue = enum {
    Null,
    Bool(bool),
    Number(f64),
    String(string),
    // TODO: 未来支持嵌套
    // Array(Vec<JsonValue>),
    // Object(Vec<JsonPair>),
}

pub type JsonPair = struct {
    key: string,
    value: JsonValue,
}

// ============================================================================
// Token 类型
// ============================================================================

// Token 类型（使用 snake_case）
type Token = enum {
    LeftBrace,      // {
    RightBrace,     // }
    LeftBracket,    // [
    RightBracket,   // ]
    Colon,          // :
    Comma,          // ,
    StringToken(string),
    NumberToken(f64),
    TrueToken,
    FalseToken,
    NullToken,
    EOF,
    Error,
}

// ============================================================================
// Lexer（词法分析器）
// ============================================================================

type Lexer = struct {
    source: string,
    position: i32,
    current_char: char,
    
    pub fn new(source: string) -> Lexer {
        let mut lexer: Lexer = Lexer {
            source: source,
            position: 0,
            current_char: source[0],
        };
        return lexer;
    }
    
    // 前进一个字符
    fn advance(mut self) -> i32 {
        self.position += 1;
        let len: i32 = 0;
        // TODO: 需要 string_length 函数
        // if self.position >= len {
        //     self.current_char = '\0';
        // } else {
        //     self.current_char = self.source[self.position];
        // }
        return 0;
    }
    
    // 跳过空白字符
    fn skip_whitespace(mut self) -> i32 {
        loop {
            let c: i32 = self.current_char as i32;
            if c == 32 || c == 9 || c == 10 || c == 13 {  // space, tab, \n, \r
                self.advance();
            } else {
                break;
            }
        }
        return 0;
    }
    
    // 解析字符串 token
    fn parse_string(mut self) -> string {
        // 跳过开始的引号
        self.advance();
        
        let start_pos: i32 = self.position;
        
        // 找到结束引号（处理转义）
        loop {
            let ch: i32 = self.current_char as i32;
            
            if ch == 34 {  // " 结束引号
                break;
            }
            
            if ch == 92 {  // \ 转义字符
                self.advance();  // 跳过 \
                if self.current_char as i32 != 0 {
                    self.advance();  // 跳过被转义的字符
                }
            } else if ch == 0 {  // 字符串未终止
                break;
            } else {
                self.advance();
            }
        }
        
        // TODO: 提取并解码子字符串
        // 当前简化：返回整个源字符串
        self.advance();  // 跳过结束引号
        return self.source;
    }
    
    // 解析数字（整数和浮点数）
    fn parse_number(mut self) -> f64 {
        let start_pos: i32 = self.position;
        let mut int_part: i32 = 0;
        let mut has_decimal: bool = false;
        let mut decimal_part: f64 = 0.0;
        let mut decimal_divisor: f64 = 10.0;
        
        // 处理负号
        let is_negative: bool = (self.current_char as i32) == 45;  // '-'
        if is_negative {
            self.advance();
        }
        
        // 解析整数部分
        loop {
            let c: i32 = self.current_char as i32;
            if c >= 48 && c <= 57 {  // 0-9
                let digit: i32 = c - 48;
                int_part = int_part * 10 + digit;
                self.advance();
            } else {
                break;
            }
        }
        
        // 解析小数部分
        if (self.current_char as i32) == 46 {  // '.'
            has_decimal = true;
            self.advance();  // 跳过 '.'
            
            loop {
                let c: i32 = self.current_char as i32;
                if c >= 48 && c <= 57 {  // 0-9
                    let digit: f64 = (c - 48) as f64;
                    decimal_part += digit / decimal_divisor;
                    decimal_divisor *= 10.0;
                    self.advance();
                } else {
                    break;
                }
            }
        }
        
        // TODO: 解析科学计数法（e/E）
        
        // 组合结果
        let mut result: f64 = int_part as f64;
        if has_decimal {
            result += decimal_part;
        }
        
        if is_negative {
            result = -result;
        }
        
        return result;
    }
    
    // 检查并解析关键字
    fn try_keyword(mut self, keyword: string, keyword_len: i32, token_type: Token) -> Token {
        let mut matches: bool = true;
        let mut i: i32 = 0;
        
        loop i in 0..keyword_len {
            let expected: i32 = keyword[i] as i32;
            let actual_pos: i32 = self.position + i;
            
            // 检查是否越界
            if actual_pos >= 10000 {  // 假设源代码不超过 10000 字符
                matches = false;
                break;
            }
            
            let actual: i32 = self.source[actual_pos] as i32;
            if actual != expected {
                matches = false;
                break;
            }
        }
        
        if matches {
            // 前进到关键字末尾
            loop i in 0..keyword_len {
                self.advance();
            }
            return token_type;
        }
        
        return Token::Error;
    }
    
    // 获取下一个 token
    pub fn next_token(mut self) -> Token {
        self.skip_whitespace();
        
        let c: i32 = self.current_char as i32;
        
        // EOF
        if c == 0 {
            return Token::EOF;
        }
        
        // 结构字符
        if c == 123 {  // {
            self.advance();
            return Token::LeftBrace;
        }
        if c == 125 {  // }
            self.advance();
            return Token::RightBrace;
        }
        if c == 91 {   // [
            self.advance();
            return Token::LeftBracket;
        }
        if c == 93 {   // ]
            self.advance();
            return Token::RightBracket;
        }
        if c == 58 {   // :
            self.advance();
            return Token::Colon;
        }
        if c == 44 {   // ,
            self.advance();
            return Token::Comma;
        }
        
        // 字符串
        if c == 34 {   // "
            let str_value: string = self.parse_string();
            return Token::StringToken(str_value);
        }
        
        // 数字（包括负数）
        if (c >= 48 && c <= 57) || c == 45 {  // 0-9 或 -
            let num_value: f64 = self.parse_number();
            return Token::NumberToken(num_value);
        }
        
        // 关键字: true (116='t')
        if c == 116 {
            return self.try_keyword("true", 4, Token::TrueToken);
        }
        
        // 关键字: false (102='f')
        if c == 102 {
            return self.try_keyword("false", 5, Token::FalseToken);
        }
        
        // 关键字: null (110='n')
        if c == 110 {
            return self.try_keyword("null", 4, Token::NullToken);
        }
        
        return Token::Error;
    }
};

// ============================================================================
// Parser（语法分析器）
// ============================================================================

type Parser = struct {
    lexer: Lexer,
    current_token: Token,
    
    pub fn new(source: string) -> Parser {
        let mut lexer: Lexer = Lexer::new(source);
        let token: Token = lexer.next_token();
        
        return Parser {
            lexer: lexer,
            current_token: token,
        };
    }
    
    fn advance(mut self) -> i32 {
        self.current_token = self.lexer.next_token();
        return 0;
    }
    
    // 解析 JSON 值（递归下降）
    pub fn parse_value(mut self) -> JsonValue {
        // 使用 is 表达式进行模式匹配
        let token: Token = self.current_token;
        
        return token is {
            NullToken => {
                self.advance();
                return JsonValue::Null;
            },
            TrueToken => {
                self.advance();
                return JsonValue::Bool(true);
            },
            FalseToken => {
                self.advance();
                return JsonValue::Bool(false);
            },
            NumberToken(num) => {
                self.advance();
                return JsonValue::Number(num);
            },
            StringToken(str) => {
                self.advance();
                return JsonValue::String(str);
            },
            _ => {
                // 错误：未知 token
                return JsonValue::Null;
            },
        };
    }
};

// ============================================================================
// 公共 API
// ============================================================================

// JSON 解析器
pub fn parse(json_str: string) -> JsonValue {
    let mut parser: Parser = Parser::new(json_str);
    return parser.parse_value();
}

// JSON 序列化（使用 StringBuilder）
pub fn stringify(value: JsonValue) -> string {
    // 使用 StringBuilder 构建 JSON 字符串
    let mut builder: StringBuilder = StringBuilder::new();
    stringify_value(mut builder, value);
    
    // TODO: 返回 builder 的内容
    // 当前简化：返回占位符
    return "{}";
}

// 递归序列化 JSON 值
fn stringify_value(mut builder: StringBuilder, value: JsonValue) -> i32 {
    // 使用 is 表达式进行模式匹配
    return value is {
        Null => {
            builder.append_string("null");
            return 1;
        },
        Bool(b) => {
            if b {
                builder.append_string("true");
            } else {
                builder.append_string("false");
            }
            return 1;
        },
        Number(n) => {
            // TODO: f64 转字符串
            // 临时：使用 i32 转换
            let int_val: i32 = n as i32;
            builder.append_i32(int_val);
            return 1;
        },
        String(s) => {
            builder.append_char('"');
            // TODO: 需要转义处理
            builder.append_string(s);
            builder.append_char('"');
            return 1;
        },
        _ => {
            builder.append_string("null");
            return 0;
        },
    };
}

// JSON 工具函数
pub fn is_valid(json_str: string) -> bool {
    // TODO: 验证JSON格式
    return true;
}

// 获取对象字段
pub fn get_field(obj: JsonValue, key: string) -> JsonValue {
    // TODO: 从JSON对象中获取字段
    return JsonValue::Null;
}

// 获取数组元素
pub fn get_index(arr: JsonValue, index: i32) -> JsonValue {
    // TODO: 从JSON数组中获取元素
    return JsonValue::Null;
}

// ============================================================================
// 辅助函数（临时，直到有内置支持）
// ============================================================================

fn string_length(s: string) -> i32 {
    let mut len: i32 = 0;
    let mut i: i32 = 0;
    
    loop i in 0..10000 {
        let ch: i32 = s[i] as i32;
        if ch == 0 {
            break;
        }
        len += 1;
    }
    
    return len;
}
