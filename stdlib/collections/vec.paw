// Vec<T> - 动态数组
// v0.2.0 - 使用动态内存（通过 Zig builtin 支持）
//
// 分层设计：
// - 第 1 层 (Zig): paw_malloc/paw_free - 内存分配
// - 第 3 层 (Paw): Vec<T> 逻辑 - 本文件

pub type Vec<T> = struct {
    ptr: i64;       // 指向内存的指针（由 paw_malloc 分配）
    length: i32;    // 当前元素数量
    capacity: i32;  // 容量
    
    // ========================================================================
    // 静态方法（构造器）- 注意：需要编译器内置支持
    // ========================================================================
    
    // 创建新的 Vec（默认容量 100）
    // pub fn new() -> Vec<T> {
    //     // 调用内置函数：let ptr = __paw_malloc(capacity * sizeof(T))
    //     // 当前简化：返回空 Vec（ptr=0）
    //     return Vec { ptr: 0, length: 0, capacity: 0 };
    // }
    
    // ========================================================================
    // 实例方法（snake_case 命名）
    // ========================================================================
    
    // 获取长度
    pub fn len(self) -> i32 {
        return self.length;
    }
    
    // 获取容量
    pub fn capacity(self) -> i32 {
        return self.capacity;
    }
    
    // 检查是否为空
    pub fn is_empty(self) -> bool {
        return self.length == 0;
    }
    
    // 添加元素到末尾
    // 注意：需要内置函数 __paw_write_i32(ptr, offset, value)
    // pub fn push(mut self, item: T) -> bool {
    //     if self.length >= self.capacity {
    //         return false;  // 容量已满（未来可以自动扩容）
    //     }
    //     
    //     // __paw_write_i32(self.ptr, self.length, item);
    //     self.length += 1;
    //     return true;
    // }
    
    // 获取元素
    // pub fn get(self, index: i32) -> T {
    //     if index < 0 || index >= self.length {
    //         // 返回默认值（需要 T::default()）
    //         return 0 as T;  // 简化
    //     }
    //     
    //     // return __paw_read_i32(self.ptr, index) as T;
    //     return 0 as T;  // 占位
    // }
    
    // 清空
    pub fn clear(mut self) {
        self.length = 0;
    }
}

// ============================================================================
// 简化版：使用固定大小包装器（不需要动态内存）
// ============================================================================

// 对于 JSON 解析器，我们可以使用固定大小的"假 Vec"
pub type JsonArray = struct {
    items: [i32; 100];  // 临时：存储索引或简单值
    length: i32;
    
    pub fn new() -> JsonArray {
        let arr: [i32; 100] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        return JsonArray { items: arr, length: 0 };
    }
    
    pub fn push(mut self, value: i32) -> bool {
        if self.length >= 100 {
            return false;
        }
        self.items[self.length] = value;
        self.length += 1;
        return true;
    }
    
    pub fn get(self, index: i32) -> i32 {
        return self.items[index];
    }
    
    pub fn len(self) -> i32 {
        return self.length;
    }
}

