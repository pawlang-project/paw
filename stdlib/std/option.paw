// std::option - 泛型Option<T>辅助函数
// 基于T?类型的泛型实现

// ========== 基础检查函数 ==========

// 检查是否为Ok值
pub fn is_ok<T>(result: T?) -> bool {
    return result is Value(v);
}

// 检查是否为Err值
pub fn is_err<T>(result: T?) -> bool {
    return result is Error(e);
}

// ========== 提取函数 ==========

// 安全unwrap：提供默认值
pub fn unwrap_or<T>(result: T?, default_val: T) -> T {
    return result is {
        Value(v) => v,
        Error(e) => default_val,
    };
}

// 获取错误消息（如果是错误）
pub fn get_error<T>(result: T?) -> string? {
    return result is {
        Value(v) => err("Not an error"),
        Error(e) => ok(e),
    };
}

// ========== 转换函数 ==========

// 将Ok值提取出来，错误时打印消息
// 注意：当前无法真正panic，只能打印错误并返回默认值
pub fn expect<T>(result: T?, message: string, default_val: T) -> T {
    if is_ok<T>(result) {
        return unwrap_or<T>(result, default_val);
    } else {
        println(message);
        let err_msg: string? = get_error<T>(result);
        if is_ok<string>(err_msg) {
            let msg: string = unwrap_or<string>(err_msg, "");
            println(msg);
        }
        return default_val;
    }
}

// ========== 链式检查 ==========

// 检查两个Result都是Ok
pub fn both_ok<T, U>(r1: T?, r2: U?) -> bool {
    return is_ok<T>(r1) && is_ok<U>(r2);
}

// 检查至少一个Result是Ok
pub fn either_ok<T, U>(r1: T?, r2: U?) -> bool {
    return is_ok<T>(r1) || is_ok<U>(r2);
}

