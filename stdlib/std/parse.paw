// std::parse - 基于?错误处理的字符串解析
// 提供类型安全的字符串到数字转换

import "std::string";
import "std::conv";

// 解析i32
pub fn parse_i32(s: string) -> i32? {
    // 检查空字符串
    let is_empty: bool = string::is_empty(s);
    if is_empty {
        return err("Empty string");
    }
    
    // 使用conv模块进行转换
    let result: i32 = conv::string_to_i32(s);
    
    // TODO: 需要实际的错误检查逻辑
    // 目前conv::string_to_i32不会失败，但实际应该检查格式
    return ok(result);
}

// 解析i64
pub fn parse_i64(s: string) -> i64? {
    let is_empty: bool = string::is_empty(s);
    if is_empty {
        return err("Empty string");
    }
    
    let result: i64 = conv::string_to_i64(s);
    return ok(result);
}

// 解析f64
pub fn parse_f64(s: string) -> f64? {
    let is_empty: bool = string::is_empty(s);
    if is_empty {
        return err("Empty string");
    }
    
    let result: f64 = conv::string_to_f64(s);
    return ok(result);
}

// 解析bool
pub fn parse_bool(s: string) -> bool? {
    let is_empty: bool = string::is_empty(s);
    if is_empty {
        return err("Empty string");
    }
    
    // 检查是否是"true"或"false"
    let is_true: bool = string::equals(s, "true");
    if is_true {
        return ok(true);
    }
    
    let is_false: bool = string::equals(s, "false");
    if is_false {
        return ok(false);
    }
    
    return err("Invalid boolean string");
}

// 解析单个字符
pub fn parse_char(s: string) -> char? {
    let len: i64 = string::len(s);
    let zero: i64 = 0;
    let one: i64 = 1;
    
    if len == zero {
        return err("Empty string");
    }
    
    if len > one {
        return err("String has more than one character");
    }
    
    let c: char = s[0];
    return ok(c);
}

