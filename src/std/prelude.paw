// Paw æ ‡å‡†åº“ Prelude
// è‡ªåŠ¨å¯¼å…¥åˆ°æ¯ä¸ª Paw ç¨‹åºä¸­

// ============================================
// 1. æ ‡å‡†è¾“å‡ºå‡½æ•°
// ============================================

// println - æ‰“å°å¹¶æ¢è¡Œ
fn println(msg: string) -> i32 {
    // å†…ç½®å‡½æ•°ï¼Œç”±ç¼–è¯‘å™¨ç‰¹æ®Šå¤„ç†
    return 0;
}

// print - æ‰“å°ä¸æ¢è¡Œ
fn print(msg: string) -> i32 {
    // å†…ç½®å‡½æ•°ï¼Œç”±ç¼–è¯‘å™¨ç‰¹æ®Šå¤„ç†
    return 0;
}

// eprintln - æ‰“å°é”™è¯¯ä¿¡æ¯å¹¶æ¢è¡Œï¼ˆè¾“å‡ºåˆ° stderrï¼‰
fn eprintln(msg: string) -> i32 {
    // å†…ç½®å‡½æ•°ï¼Œç”±ç¼–è¯‘å™¨ç‰¹æ®Šå¤„ç†
    return 0;
}

// eprint - æ‰“å°é”™è¯¯ä¿¡æ¯ä¸æ¢è¡Œï¼ˆè¾“å‡ºåˆ° stderrï¼‰
fn eprint(msg: string) -> i32 {
    // å†…ç½®å‡½æ•°ï¼Œç”±ç¼–è¯‘å™¨ç‰¹æ®Šå¤„ç†
    return 0;
}

// ============================================
// 2. Result<T, E> - é”™è¯¯å¤„ç†ç±»å‹
// ============================================

type Result = enum {
    Ok(i32),
    Err(i32),
}

// ============================================
// 3. Option<T> - å¯é€‰ç±»å‹
// ============================================

type Option = enum {
    Some(i32),
    None(),
}

// ============================================
// 4. Vec<T> - åŠ¨æ€æ•°ç»„ï¼ˆæ³›å‹ç»“æ„ä½“ï¼‰
// ============================================

type Vec<T> = struct {
    ptr: i32,       // ç®€åŒ–ï¼šå®é™…åº”ä¸º *Tï¼ˆæ•°æ®æŒ‡é’ˆï¼‰
    len: i32,       // å½“å‰é•¿åº¦
    cap: i32,       // å®¹é‡
    
    // ğŸ†• v0.1.2: æ³›å‹é™æ€æ–¹æ³•
    fn new() -> Vec<T> {
        return Vec { ptr: 0, len: 0, cap: 0 };
    }
    
    fn with_capacity(capacity: i32) -> Vec<T> {
        return Vec { ptr: 0, len: 0, cap: capacity };
    }
    
    // ğŸ†• v0.1.2: æ³›å‹å®ä¾‹æ–¹æ³•ï¼ˆselfä¸å¸¦ç±»å‹ï¼ï¼‰
    fn length(self) -> i32 {
        return self.len;
    }
    
    fn capacity_method(self) -> i32 {
        return self.cap;
    }
}

// ============================================
// 5. Box<T> - æ™ºèƒ½æŒ‡é’ˆï¼ˆæ³›å‹ç»“æ„ä½“ï¼‰
// ============================================

type Box<T> = struct {
    value: T,
    
    // ğŸ†• v0.1.2: æ³›å‹é™æ€æ–¹æ³•
    fn new(val: T) -> Box<T> {
        return Box { value: val };
    }
}

// ============================================
// 6. æ•°ç»„å’Œé›†åˆæ“ä½œ
// ============================================

// æ³¨æ„ï¼šä»¥ä¸‹å‡½æ•°éœ€è¦æ³›å‹æ–¹æ³•æ”¯æŒï¼ˆv0.1.2ï¼‰
// å½“å‰ç‰ˆæœ¬ä»…æä¾›ç±»å‹å®šä¹‰

// ============================================
// 7. æœªæ¥æ‰©å±•ï¼ˆv0.1.2+ï¼‰
// ============================================

// è®¡åˆ’æ·»åŠ ï¼š
// - æ³›å‹æ–¹æ³•ï¼ˆVec<T>::new, Box<T>::newï¼‰
// - æ•°å­¦å‡½æ•°ï¼ˆabs, min, maxï¼‰
// - å­—ç¬¦ä¸²æ“ä½œï¼ˆlen, concat, splitï¼‰
// - æ–­è¨€å‡½æ•°ï¼ˆassert, panicï¼‰
// - æ–‡ä»¶ I/O
// - ç½‘ç»œæ“ä½œ